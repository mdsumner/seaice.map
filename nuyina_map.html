<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vessel Track Map Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a0a;
        }

        #canvas {
            position: absolute;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        #controls {
            background: #2a2a2a;
            padding: 20px;
            border-top: 1px solid #404040;
        }

        #timeline {
            margin-bottom: 15px;
        }

        #slider-container {
            position: relative;
            height: 40px;
            margin-bottom: 10px;
        }

        .time-slider {
            position: absolute;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            pointer-events: none;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 3;
        }

        .time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            border: none;
            pointer-events: auto;
        }

        #slider-end::-webkit-slider-thumb {
            background: #ff6b6b;
        }

        #slider-end::-moz-range-thumb {
            background: #ff6b6b;
        }

        #slider-track {
            position: absolute;
            height: 8px;
            background: #404040;
            border-radius: 4px;
            width: 100%;
            top: 16px;
        }

        #slider-range {
            position: absolute;
            height: 8px;
            background: #4a9eff;
            border-radius: 4px;
            top: 16px;
            cursor: pointer;
        }

        #date-range {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            margin-bottom: 10px;
        }

        .date-time-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .time-input {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 12px;
        }

        .time-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        #datetime-readout {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            text-align: right;
            line-height: 1.4;
        }

        #datetime-readout .start-time,
        #datetime-readout .end-time {
            color: #888;
        }

        #info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 14px;
        }

        #date-display {
            font-weight: 600;
            color: #4a9eff;
            font-size: 16px;
        }

        .controls-group {
            display: flex;
            gap: 10px;
        }

        button {
            background: #404040;
            color: #e0e0e0;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #505050;
        }

        button:active {
            background: #353535;
        }

        #loading {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.9);
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }

        .status {
            font-size: 12px;
            color: #999;
        }

        #help-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
        }

        #help-panel.visible {
            display: block;
        }

        #help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 999;
        }

        #help-overlay.visible {
            display: block;
        }

        #help-panel h2 {
            margin-top: 0;
            color: #4a9eff;
        }

        #help-panel h3 {
            color: #ff6b6b;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        #help-panel ul {
            line-height: 1.6;
            padding-left: 20px;
        }

        #help-panel li {
            margin-bottom: 8px;
        }

        #help-panel code {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        .close-help {
            float: right;
            background: #404040;
            border: none;
            color: #e0e0e0;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .close-help:hover {
            background: #505050;
        }

        #zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            font-weight: bold;
        }

        #coastline-toggle.active {
            background: #4a9eff;
        }

        #external-links {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(26, 26, 26, 0.9);
            padding: 10px;
            border-radius: 6px;
        }

        .link-group-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        .link-group-label:first-child {
            margin-top: 0;
        }

        .external-link {
            color: #e0e0e0;
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            transition: background 0.2s;
            display: block;
        }

        .external-link:hover {
            background: rgba(74, 158, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="help-overlay" onclick="toggleHelp()"></div>
        <div id="help-panel">
            <button class="close-help" onclick="toggleHelp()">‚úï Close</button>
            <h2>Vessel Track Map Viewer</h2>

            <h3>üìÖ Timeline Controls</h3>
            <ul>
                <li><strong>Previous/Next Period:</strong> Navigate between year-long periods (2020-2025)</li>
                <li><strong>Blue slider (left):</strong> Start date of the range</li>
                <li><strong>Red slider (right):</strong> End date of the range</li>
                <li><strong>Blue highlighted bar:</strong> Click and drag to slide the entire time window</li>
                <li><strong>Vessel track:</strong> Displays only within the selected date range</li>
            </ul>

            <h3>‚ñ∂Ô∏è Animation</h3>
            <ul>
                <li><strong>Play (‚ñ∂):</strong> Animate the time window forward</li>
                <li><strong>Reverse (‚óÄ):</strong> Animate the time window backward</li>
                <li><strong>Pause (‚è∏):</strong> Stop animation</li>
                <li><strong>‚èÆ Start:</strong> Snap to start of period (or previous period if already at start)</li>
                <li><strong>End ‚è≠:</strong> Snap to end of period (or next period if already at end)</li>
                <li><strong>Speed slider:</strong> Adjust animation speed (0.1s to 2.0s per frame)</li>
            </ul>

            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <ul>
                <li><strong>Home:</strong> Snap to start (or previous period)</li>
                <li><strong>End:</strong> Snap to end (or next period)</li>
                <li><strong>Space:</strong> Toggle play/pause animation</li>
                <li><strong>Arrow Left:</strong> Previous period</li>
                <li><strong>Arrow Right:</strong> Next period</li>
            </ul>

            <h3>üó∫Ô∏è Map Navigation</h3>
            <ul>
                <li><strong>Click and drag:</strong> Pan the map</li>
                <li><strong>Mouse wheel:</strong> Zoom in/out at cursor position</li>
                <li><strong>+ button:</strong> Zoom in at center</li>
                <li><strong>‚àí button:</strong> Zoom out at center</li>
                <li><strong>‚åÇ button:</strong> Reset to original view</li>
            </ul>

            <h3>üö¢ Vessel Track</h3>
            <ul>
                <li><strong>Red line:</strong> Vessel path during selected time range</li>
                <li><strong>Red dot:</strong> Vessel position at end of range</li>
                <li><strong>Tip:</strong> Set start = end for a single-day snapshot</li>
            </ul>

            <h3>üñºÔ∏è Background Images</h3>
            <ul>
                <li>Background image aligns to the <strong>end date</strong> of the range</li>
                <li>If an image is missing, the viewer automatically uses the nearest earlier date</li>
                <li>Status message shows if a fallback image is being used</li>
            </ul>
        </div>

        <div id="map-container">
            <canvas id="canvas"></canvas>
            <div id="loading">Loading...</div>
            <div id="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <button class="zoom-btn" onclick="resetView()">‚åÇ</button>
                <button class="zoom-btn" onclick="toggleCoastline()" id="coastline-toggle" title="Toggle coastline">üó∫Ô∏è</button>
            </div>
            <div id="external-links">
                <div class="link-group-label">üìç Vessel Position</div>
                <a id="link-vessel-esa" class="external-link" href="#" target="_blank">üõ∞Ô∏è ESA Copernicus</a>
                <a id="link-vessel-maxar" class="external-link" href="#" target="_blank">üì∑ Maxar Xpress</a>
                <a id="link-vessel-gmap" class="external-link" href="#" target="_blank">üó∫Ô∏è Google Maps</a>
                <div class="link-group-label">üéØ View Center</div>
                <a id="link-view-esa" class="external-link" href="#" target="_blank">üõ∞Ô∏è ESA Copernicus</a>
                <a id="link-view-maxar" class="external-link" href="#" target="_blank">üì∑ Maxar Xpress</a>
                <a id="link-view-gmap" class="external-link" href="#" target="_blank">üó∫Ô∏è Google Maps</a>
            </div>
        </div>

        <div id="controls">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="prev-page" onclick="prevPage()">‚óÑ Previous Period</button>
                    <span id="page-info" style="font-size: 14px; color: #999;"></span>
                    <button id="next-page" onclick="nextPage()">Next Period ‚ñ∫</button>
                </div>
                <div id="datetime-readout">
                    <div class="start-time"><span id="start-datetime"></span></div>
                    <div class="end-time"><span id="end-datetime"></span></div>
                </div>
            </div>
            <div id="timeline">
                <div id="slider-container">
                    <div id="slider-track"></div>
                    <div id="slider-range"></div>
                    <input type="range" id="slider-start" class="time-slider" min="0" max="364" value="350" step="1">
                    <input type="range" id="slider-end" class="time-slider" min="0" max="364" value="364" step="1">
                </div>
                <div id="date-range">
                    <div class="date-time-input">
                        <span id="start-date"></span>
                        <input type="time" id="start-time-input" class="time-input" value="00:00" step="600" title="Start time (UTC)">
                        <span style="color: #666;">UTC</span>
                    </div>
                    <div class="date-time-input">
                        <input type="time" id="end-time-input" class="time-input" value="23:59" step="600" title="End time (UTC)">
                        <span style="color: #666;">UTC</span>
                        <span id="end-date"></span>
                    </div>
                </div>
            </div>
            <div id="info">
                <div id="date-display">Loading...</div>
                <div class="status" id="status">Initializing...</div>
                <div class="controls-group">
                    <button onclick="snapToStart()" title="Snap to start of period (Home)">‚èÆ Start</button>
                    <button onclick="playReverse()">‚óÄ Reverse</button>
                    <button onclick="playAnimation()">‚ñ∂ Play</button>
                    <button onclick="stopAnimation()">‚è∏ Pause</button>
                    <button onclick="snapToEnd()" title="Snap to end of period (End)">End ‚è≠</button>
                    <label style="margin-left: 15px; display: flex; align-items: center; gap: 8px;">
                        Speed:
                        <input type="range" id="speed-slider" min="100" max="2000" value="500" step="100"
                               style="width: 100px; height: 6px;">
                        <span id="speed-display">0.5s</span>
                    </label>
                </div>
                <button onclick="toggleHelp()" style="margin-left: auto;">‚ùì Help</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            imageBaseUrl: 'https://projects.pawsey.org.au/nuyina.map/NOAA/G02135',
            trackUrl: 'https://projects.pawsey.org.au/nuyina.map/vessel/vessel_track_hourly.json',
            daysPerPage: 365,  // Show 1 year per page
            endDate: (() => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                return today;
            })(),  // Use today - vessel data up to date, background image falls back to latest available
            startDate: new Date('2020-06-01T00:00:00Z'),  // Start from June 1st for seasonal alignment
            // Hardcoded metadata (WKT from .aux.xml not supported by proj4js)
            projection: '+proj=tmerc +lat_0=0 +lon_0=115 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs',
            extent: {
                xmin: -6007500,
                xmax: 6012500,
                ymin: -14422000,
                ymax: 14418000
            },
            imageWidth: 601,
            imageHeight: 1442

            // NOTE: .aux.xml metadata loading available but WKT format not supported by proj4js
            // To use .aux.xml, set projection/extent/imageWidth/imageHeight to null
            // and ensure .aux.xml contains PROJ.4 format string (not WKT)
        };

        // State
        let state = {
            canvas: null,
            ctx: null,
            dates: [],
            allDates: [],  // All available dates across all pages
            currentPage: 0,
            totalPages: 0,
            startDateIndex: 0,
            endDateIndex: 0,
            startTimeUTC: '00:00',  // HH:MM in UTC
            endTimeUTC: '23:59',    // HH:MM in UTC
            vesselTrack: [],
            transform: {
                scale: 1,
                offsetX: 0,
                offsetY: 0
            },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            animationId: null,
            imageCache: {},
            currentImage: null,
            isRangeDragging: false,
            rangeDragStartIndex: 0,
            animationSpeed: 500,  // milliseconds per frame
            coastline: null,
            showCoastline: true,
            transformer: null  // Will be initialized after loading metadata
        };

        // proj4 transformer will be initialized after metadata loads

        // Load and parse GDAL PAM metadata
        async function loadMetadata(auxUrl) {
            try {
                updateStatus('Loading metadata...');
                const response = await fetch(auxUrl);
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                // Extract SRS (projection)
                const srsElement = xmlDoc.querySelector('SRS');
                if (srsElement) {
                    CONFIG.projection = srsElement.textContent.trim();
                }

                // Extract GeoTransform
                const geoTransformElement = xmlDoc.querySelector('GeoTransform');
                if (geoTransformElement) {
                    const values = geoTransformElement.textContent.trim().split(',').map(v => parseFloat(v.trim()));
                    // GeoTransform format: [x_origin, pixel_width, 0, y_origin, 0, -pixel_height]
                    const xOrigin = values[0];
                    const pixelWidth = values[1];
                    const yOrigin = values[3];
                    const pixelHeight = -values[5]; // Negative in geotransform

                    // Get raster dimensions
                    const rasterXSize = parseInt(xmlDoc.querySelector('PAMDataset').getAttribute('RasterXSize'));
                    const rasterYSize = parseInt(xmlDoc.querySelector('PAMDataset').getAttribute('RasterYSize'));

                    CONFIG.imageWidth = rasterXSize;
                    CONFIG.imageHeight = rasterYSize;

                    // Calculate extent
                    CONFIG.extent = {
                        xmin: xOrigin,
                        xmax: xOrigin + (rasterXSize * pixelWidth),
                        ymin: yOrigin - (rasterYSize * pixelHeight),
                        ymax: yOrigin
                    };
                }

                // Initialize proj4 transformer
                console.log('Creating proj4 transformer with projection:', CONFIG.projection.substring(0, 100) + '...');
                proj4.defs('CUSTOM', CONFIG.projection);
                state.transformer = proj4('EPSG:4326', 'CUSTOM');
                console.log('Transformer created:', state.transformer);

                // Test the transformer
                const testResult = state.transformer.forward([147, -43]);
                console.log('Test transform [147, -43] =>', testResult);

                updateStatus('Metadata loaded');
                console.log('Loaded metadata:', {
                    projection: CONFIG.projection,
                    extent: CONFIG.extent,
                    imageSize: [CONFIG.imageWidth, CONFIG.imageHeight]
                });

                return true;
            } catch (e) {
                console.error('Failed to load metadata:', e);
                updateStatus('Failed to load metadata');
                return false;
            }
        }

        // Generate all available dates
        function generateAllDates() {
            const dates = [];
            const start = new Date(CONFIG.startDate);
            const end = new Date(CONFIG.endDate);

            let current = new Date(start);
            while (current <= end) {
                dates.push(new Date(current));
                current.setDate(current.getDate() + 1);
            }

            return dates;
        }

        // Get dates for current page
        function getPageDates() {
            const startIdx = state.currentPage * CONFIG.daysPerPage;
            const endIdx = Math.min(startIdx + CONFIG.daysPerPage, state.allDates.length);
            return state.allDates.slice(startIdx, endIdx);
        }

        // Update page
        function setPage(pageNum) {
            state.currentPage = Math.max(0, Math.min(pageNum, state.totalPages - 1));
            state.dates = getPageDates();

            // Reset range to last 14 days of current page
            state.endDateIndex = state.dates.length - 1;
            state.startDateIndex = Math.max(0, state.endDateIndex - 13);

            // Update sliders
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            sliderStart.max = state.dates.length - 1;
            sliderEnd.max = state.dates.length - 1;
            sliderStart.value = state.startDateIndex;
            sliderEnd.value = state.endDateIndex;

            updateSliderRange();
            updatePageDisplay();
            updateDisplay();
        }

        function nextPage() {
            if (state.currentPage < state.totalPages - 1) {
                setPage(state.currentPage + 1);
            }
        }

        function prevPage() {
            if (state.currentPage > 0) {
                setPage(state.currentPage - 1);
            }
        }

        function updatePageDisplay() {
            const pageInfo = document.getElementById('page-info');
            const startDate = formatDate(state.dates[0]);
            const endDate = formatDate(state.dates[state.dates.length - 1]);
            pageInfo.textContent = `Period: ${startDate} to ${endDate} (Page ${state.currentPage + 1}/${state.totalPages})`;

            // Enable/disable buttons
            document.getElementById('prev-page').disabled = state.currentPage === 0;
            document.getElementById('next-page').disabled = state.currentPage === state.totalPages - 1;
        }

        // Format date as YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        // Format datetime as YYYY-MM-DD HH:MM:SS UTC
        function formatDateTime(date) {
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
        }

        // Get full datetime from date index and time string (HH:MM in UTC)
        function getFullDateTime(dateIndex, timeUTC) {
            const date = state.dates[dateIndex];
            const [hours, minutes] = timeUTC.split(':').map(Number);
            const fullDate = new Date(date);
            fullDate.setUTCHours(hours, minutes, 0, 0);
            return fullDate;
        }

        // Get image URL for a date
        function getImageUrl(date) {
            const dateStr = formatDate(date);
            const year = date.getFullYear();
            const url = `${CONFIG.imageBaseUrl}/${year}/concentration_v4.0_${dateStr}.png`;

            // Uncomment to use CORS proxy (for testing only):
            // return `https://corsproxy.io/?${encodeURIComponent(url)}`;

            return url;
        }

        // Load image with fallback
        // Searches backwards from the selected date, falling back to earlier dates if image not available
        // This allows the slider to extend beyond available images while showing the latest available image
        async function loadImageWithFallback(dateIndex) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            const targetDate = state.dates[dateIndex];

            // First, try images from current page (from dateIndex back to start of page)
            for (let i = dateIndex; i >= 0; i--) {
                const date = state.dates[i];
                const url = getImageUrl(date);

                // Check cache first
                if (state.imageCache[url]) {
                    loading.style.display = 'none';
                    const isFallback = date.getTime() !== targetDate.getTime();
                    updateStatus(isFallback ?
                        `Using fallback image from ${formatDate(date)}` :
                        'Image loaded');
                    return { image: state.imageCache[url], date };
                }

                try {
                    const img = await loadImage(url);
                    state.imageCache[url] = img;
                    loading.style.display = 'none';
                    const isFallback = date.getTime() !== targetDate.getTime();
                    updateStatus(isFallback ?
                        `Using fallback image from ${formatDate(date)}` :
                        'Image loaded');
                    return { image: img, date };
                } catch (e) {
                    // Try previous date
                    continue;
                }
            }

            // If we're not on the first page, search previous pages for an available image
            // Calculate global index and search backwards through allDates
            const globalStartIndex = state.currentPage * CONFIG.daysPerPage;
            for (let globalIdx = globalStartIndex - 1; globalIdx >= 0; globalIdx--) {
                const date = state.allDates[globalIdx];
                const url = getImageUrl(date);

                // Check cache first
                if (state.imageCache[url]) {
                    loading.style.display = 'none';
                    updateStatus(`Using fallback image from ${formatDate(date)}`);
                    return { image: state.imageCache[url], date };
                }

                try {
                    const img = await loadImage(url);
                    state.imageCache[url] = img;
                    loading.style.display = 'none';
                    updateStatus(`Using fallback image from ${formatDate(date)}`);
                    return { image: img, date };
                } catch (e) {
                    // Try previous date
                    continue;
                }
            }

            loading.style.display = 'none';
            updateStatus('No images available');
            return null;
        }

        // Load image promise
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        // Convert lon/lat to pixel coordinates
        function lonLatToPixel(lon, lat) {
            // Transform to projected coordinates
            try {
                const result = state.transformer.forward([lon, lat]);
                const [x, y] = result;

                // Convert projected coordinates to pixel coordinates
                const pixelX = ((x - CONFIG.extent.xmin) / (CONFIG.extent.xmax - CONFIG.extent.xmin)) * CONFIG.imageWidth;
                const pixelY = ((CONFIG.extent.ymax - y) / (CONFIG.extent.ymax - CONFIG.extent.ymin)) * CONFIG.imageHeight;

                return { x: pixelX, y: pixelY };
            } catch (e) {
                console.error('Transform error for', lon, lat, ':', e.message);
                return { x: NaN, y: NaN };
            }
        }

        // Load coastline data
        async function loadCoastline() {
            try {
                // Using simplified GeoJSON coastline
                const response = await fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_coastline.geojson');
                const data = await response.json();

                console.log('Coastline data loaded:', data.features.length, 'features');

                // Calculate maximum reasonable segment length (e.g., 20% of image height)
                const maxSegmentLength = CONFIG.imageHeight * 0.2;

                // Convert GeoJSON to pixel coordinates and filter out wrap-around segments
                const coastlinePixels = [];

                data.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        const coords = feature.geometry.coordinates.map(coord => {
                            const [lon, lat] = coord;
                            return lonLatToPixel(lon, lat);
                        });

                        // Split into segments, filtering out long ones
                        const segments = splitAndFilterSegments(coords, maxSegmentLength);
                        coastlinePixels.push(...segments);

                    } else if (feature.geometry.type === 'MultiLineString') {
                        feature.geometry.coordinates.forEach(lineString => {
                            const coords = lineString.map(coord => {
                                const [lon, lat] = coord;
                                return lonLatToPixel(lon, lat);
                            });

                            // Split into segments, filtering out long ones
                            const segments = splitAndFilterSegments(coords, maxSegmentLength);
                            coastlinePixels.push(...segments);
                        });
                    }
                });

                console.log('Coastline pixels:', coastlinePixels.length, 'line segments');
                state.coastline = coastlinePixels;
                updateStatus('Coastline loaded');
                render();
            } catch (e) {
                console.error('Failed to load coastline:', e);
                updateStatus('Coastline unavailable');
                state.coastline = null;
            }
        }

        // Split a line into segments, removing those that are too long (wrap-around artifacts)
        function splitAndFilterSegments(coords, maxLength) {
            const segments = [];
            let currentSegment = [];

            for (let i = 0; i < coords.length; i++) {
                const point = coords[i];

                if (currentSegment.length > 0) {
                    const prevPoint = currentSegment[currentSegment.length - 1];
                    const dx = point.x - prevPoint.x;
                    const dy = point.y - prevPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > maxLength) {
                        // This segment is too long (likely a wrap-around)
                        // Save current segment if it has multiple points
                        if (currentSegment.length > 1) {
                            segments.push(currentSegment);
                        }
                        // Start a new segment
                        currentSegment = [point];
                    } else {
                        currentSegment.push(point);
                    }
                } else {
                    currentSegment.push(point);
                }
            }

            // Add the last segment
            if (currentSegment.length > 1) {
                segments.push(currentSegment);
            }

            return segments;
        }

        // Toggle coastline visibility
        function toggleCoastline() {
            state.showCoastline = !state.showCoastline;
            const btn = document.getElementById('coastline-toggle');
            if (state.showCoastline) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            render();
        }

        // Update external links based on current vessel position
        function updateExternalLinks() {
            const endDate = state.dates[state.endDateIndex];

            // Format date for ESA (end date of range)
            const esaDate = formatDate(endDate);
            const fromTime = `${esaDate}T00:00:00.000Z`;
            const toTime = `${esaDate}T23:59:59.999Z`;

            // Update vessel position links
            let vesselLat = null;
            let vesselLon = null;

            if (state.vesselTrack.length > 0) {
                const startDateTime = getFullDateTime(state.startDateIndex, state.startTimeUTC);
                const endDateTime = getFullDateTime(state.endDateIndex, state.endTimeUTC);
                const relevantPoints = state.vesselTrack.filter(p =>
                    p.datetime >= startDateTime && p.datetime <= endDateTime
                );

                if (relevantPoints.length > 0) {
                    const lastPoint = relevantPoints[relevantPoints.length - 1];
                    vesselLat = lastPoint.lat;
                    vesselLon = lastPoint.lon;
                }
            }

            // If we have vessel position, update vessel links
            if (vesselLat !== null && vesselLon !== null) {
                // ESA Copernicus Browser
                const esaUrl = `https://browser.dataspace.copernicus.eu/?zoom=12&lat=${vesselLat}&lng=${vesselLon}&fromTime=${encodeURIComponent(fromTime)}&toTime=${encodeURIComponent(toTime)}&datasetId=S2_L2A_CDAS&cloudCoverage=30&dateMode=SINGLE`;
                document.getElementById('link-vessel-esa').href = esaUrl;

                // Maxar Xpress
                const maxarUrl = `https://xpress.maxar.com/?lat=${vesselLat}&lon=${vesselLon}&zoom=10`;
                document.getElementById('link-vessel-maxar').href = maxarUrl;

                // Google Maps
                const gmapUrl = `https://www.google.com/maps/@${vesselLat},${vesselLon},30000m/data=!3m1!1e3`;
                document.getElementById('link-vessel-gmap').href = gmapUrl;
            }

            // Update view center links
            updateViewCenterLinks(fromTime, toTime);
        }

        // Convert pixel coordinates to lon/lat (inverse transform)
        function pixelToLonLat(pixelX, pixelY) {
            // Convert pixel to projected coordinates
            const x = CONFIG.extent.xmin + (pixelX / CONFIG.imageWidth) * (CONFIG.extent.xmax - CONFIG.extent.xmin);
            const y = CONFIG.extent.ymax - (pixelY / CONFIG.imageHeight) * (CONFIG.extent.ymax - CONFIG.extent.ymin);

            // Inverse transform from projected to lon/lat
            const [lon, lat] = state.transformer.inverse([x, y]);
            return { lon, lat };
        }

        // Update view center links based on current pan/zoom
        function updateViewCenterLinks(fromTime, toTime) {
            if (!state.transformer || !CONFIG.imageWidth) return;

            const canvas = state.canvas;
            const scale = state.transform.scale;
            const offsetX = state.transform.offsetX;
            const offsetY = state.transform.offsetY;

            // Calculate center of view in pixel coordinates
            const viewCenterX = (canvas.width / 2 - offsetX) / scale;
            const viewCenterY = (canvas.height / 2 - offsetY) / scale;

            // Convert to lon/lat
            const center = pixelToLonLat(viewCenterX, viewCenterY);
            const lat = center.lat;
            const lon = center.lon;

            // ESA Copernicus Browser
            const esaUrl = `https://browser.dataspace.copernicus.eu/?zoom=12&lat=${lat}&lng=${lon}&fromTime=${encodeURIComponent(fromTime)}&toTime=${encodeURIComponent(toTime)}&datasetId=S2_L2A_CDAS&cloudCoverage=30&dateMode=SINGLE`;
            document.getElementById('link-view-esa').href = esaUrl;

            // Maxar Xpress
            const maxarUrl = `https://xpress.maxar.com/?lat=${lat}&lon=${lon}&zoom=10`;
            document.getElementById('link-view-maxar').href = maxarUrl;

            // Google Maps
            const gmapUrl = `https://www.google.com/maps/@${lat},${lon},30000m/data=!3m1!1e3`;
            document.getElementById('link-view-gmap').href = gmapUrl;
        }

        // Load vessel track
        async function loadVesselTrack() {
            console.log('Starting to load vessel track from:', CONFIG.trackUrl);
            try {
                const response = await fetch(CONFIG.trackUrl);
                console.log('Vessel track response status:', response.status);
                const data = await response.json();

                console.log('Vessel track raw data:', data.length, 'points');
                console.log('First point:', data[0]);
                console.log('Last point:', data[data.length - 1]);

                // Convert to pixel coordinates
                state.vesselTrack = data.map(point => {
                    const pixels = lonLatToPixel(point.longitude, point.latitude);
                    return {
                        datetime: new Date(point.datetime),
                        x: pixels.x,
                        y: pixels.y,
                        lon: point.longitude,
                        lat: point.latitude
                    };
                });

                console.log('Vessel track converted:', state.vesselTrack.length, 'points');
                console.log('First converted:', state.vesselTrack[0]);
                console.log('Last converted:', state.vesselTrack[state.vesselTrack.length-1]);
                updateStatus(`Loaded ${state.vesselTrack.length} track points`);

                // Return the date range of the vessel track
                // Use reduce instead of spread to avoid call stack overflow with large arrays
                if (state.vesselTrack.length > 0) {
                    let minDate = state.vesselTrack[0].datetime;
                    let maxDate = state.vesselTrack[0].datetime;
                    for (let i = 1; i < state.vesselTrack.length; i++) {
                        const dt = state.vesselTrack[i].datetime;
                        if (dt < minDate) minDate = dt;
                        if (dt > maxDate) maxDate = dt;
                    }
                    console.log('Track date range:', minDate.toISOString(), 'to', maxDate.toISOString());
                    return { minDate, maxDate };
                }
                return null;
            } catch (e) {
                console.error('Failed to load vessel track:', e);
                updateStatus('Failed to load vessel track');
                return null;
            }
        }

        // Render canvas
        function render() {
            const canvas = state.canvas;
            const ctx = state.ctx;

            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!state.currentImage) return;

            // Calculate transform
            const scale = state.transform.scale;
            const offsetX = state.transform.offsetX;
            const offsetY = state.transform.offsetY;

            // Draw image
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.drawImage(state.currentImage, 0, 0, CONFIG.imageWidth, CONFIG.imageHeight);
            ctx.restore();

            // Draw coastline
            if (state.showCoastline && state.coastline) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1 / scale;  // Adjust line width based on zoom

                state.coastline.forEach(ring => {
                    if (ring.length < 2) return;

                    ctx.beginPath();
                    ctx.moveTo(ring[0].x, ring[0].y);
                    for (let i = 1; i < ring.length; i++) {
                        ctx.lineTo(ring[i].x, ring[i].y);
                    }
                    ctx.stroke();
                });

                ctx.restore();
            }

            // Draw vessel track for the selected date/time range
            if (state.vesselTrack.length > 0) {
                const startDateTime = getFullDateTime(state.startDateIndex, state.startTimeUTC);
                const endDateTime = getFullDateTime(state.endDateIndex, state.endTimeUTC);
                const relevantPoints = state.vesselTrack.filter(p =>
                    p.datetime >= startDateTime && p.datetime <= endDateTime
                );

                if (relevantPoints.length > 0) {
                    // Draw track line
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    relevantPoints.forEach((point, i) => {
                        const x = point.x * scale + offsetX;
                        const y = point.y * scale + offsetY;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });

                    ctx.stroke();

                    // Draw end position (last point in range)
                    const lastPoint = relevantPoints[relevantPoints.length - 1];
                    const x = lastPoint.x * scale + offsetX;
                    const y = lastPoint.y * scale + offsetY;

                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Update view center links after render (for pan/zoom changes)
            if (state.dates && state.dates.length > 0) {
                const endDate = state.dates[state.endDateIndex];
                const esaDate = formatDate(endDate);
                const fromTime = `${esaDate}T00:00:00.000Z`;
                const toTime = `${esaDate}T23:59:59.999Z`;
                updateViewCenterLinks(fromTime, toTime);
            }
        }

        // Update display
        async function updateDisplay() {
            const result = await loadImageWithFallback(state.endDateIndex);
            if (result) {
                state.currentImage = result.image;
                document.getElementById('date-display').textContent =
                    `${formatDate(state.dates[state.startDateIndex])} ‚Üí ${formatDate(result.date)}`;
                render();
                updateExternalLinks();
            }
        }

        // Update slider range visual
        function updateSliderRange() {
            const sliderRange = document.getElementById('slider-range');
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');

            const percent1 = (state.startDateIndex / (state.dates.length - 1)) * 100;
            const percent2 = (state.endDateIndex / (state.dates.length - 1)) * 100;

            sliderRange.style.left = percent1 + '%';
            sliderRange.style.width = (percent2 - percent1) + '%';

            // Update date range display
            document.getElementById('start-date').textContent = formatDate(state.dates[state.startDateIndex]);
            document.getElementById('end-date').textContent = formatDate(state.dates[state.endDateIndex]);

            // Sync time inputs with state
            document.getElementById('start-time-input').value = state.startTimeUTC;
            document.getElementById('end-time-input').value = state.endTimeUTC;

            // Update datetime readout with actual track boundaries
            const startDateTime = getFullDateTime(state.startDateIndex, state.startTimeUTC);
            const endDateTime = getFullDateTime(state.endDateIndex, state.endTimeUTC);

            // Find actual first and last track points in the selected range
            if (state.vesselTrack.length > 0) {
                const relevantPoints = state.vesselTrack.filter(p =>
                    p.datetime >= startDateTime && p.datetime <= endDateTime
                );

                if (relevantPoints.length > 0) {
                    const firstPoint = relevantPoints[0];
                    const lastPoint = relevantPoints[relevantPoints.length - 1];
                    document.getElementById('start-datetime').textContent =
                        `${formatDateTime(firstPoint.datetime)} (${relevantPoints.length} pts)`;
                    document.getElementById('end-datetime').textContent = formatDateTime(lastPoint.datetime);
                } else {
                    document.getElementById('start-datetime').textContent = 'No track data in range';
                    document.getElementById('end-datetime').textContent = '';
                }
            } else {
                document.getElementById('start-datetime').textContent = formatDateTime(startDateTime);
                document.getElementById('end-datetime').textContent = formatDateTime(endDateTime);
            }
        }

        // Fit image to canvas
        function fitImageToCanvas() {
            const canvas = state.canvas;
            const scaleX = canvas.width / CONFIG.imageWidth;
            const scaleY = canvas.height / CONFIG.imageHeight;
            const scale = Math.min(scaleX, scaleY);

            state.transform.scale = scale;
            state.transform.offsetX = (canvas.width - CONFIG.imageWidth * scale) / 2;
            state.transform.offsetY = (canvas.height - CONFIG.imageHeight * scale) / 2;
        }

        // Zoom functions
        function zoomIn() {
            const canvas = state.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            zoom(1.2, centerX, centerY);
        }

        function zoomOut() {
            const canvas = state.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            zoom(0.8, centerX, centerY);
        }

        function zoom(factor, centerX, centerY) {
            const oldScale = state.transform.scale;
            const newScale = oldScale * factor;

            // Calculate new offset to zoom towards center point
            state.transform.offsetX = centerX - (centerX - state.transform.offsetX) * (newScale / oldScale);
            state.transform.offsetY = centerY - (centerY - state.transform.offsetY) * (newScale / oldScale);
            state.transform.scale = newScale;

            render();
        }

        function resetView() {
            fitImageToCanvas();
            render();
        }

        // Animation
        function playAnimation() {
            if (state.animationId) {
                stopAnimation();
            }

            state.animationId = setInterval(() => {
                const rangeDuration = state.endDateIndex - state.startDateIndex;

                if (state.endDateIndex < state.dates.length - 1) {
                    // Move both start and end forward by 1, maintaining range duration
                    state.startDateIndex++;
                    state.endDateIndex++;

                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                } else if (state.currentPage < state.totalPages - 1) {
                    // Reached end of current page, advance to next page
                    setPage(state.currentPage + 1);
                    // Continue playing
                } else {
                    // Reached the very end
                    stopAnimation();
                }
            }, state.animationSpeed);
        }

        function stopAnimation() {
            if (state.animationId) {
                clearInterval(state.animationId);
                state.animationId = null;
            }
        }

        function playReverse() {
            if (state.animationId) {
                stopAnimation();
            }

            state.animationId = setInterval(() => {
                const rangeDuration = state.endDateIndex - state.startDateIndex;

                if (state.startDateIndex > 0) {
                    // Move both start and end backward by 1, maintaining range duration
                    state.startDateIndex--;
                    state.endDateIndex--;

                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                } else if (state.currentPage > 0) {
                    // Reached start of current page, go back to previous page
                    setPage(state.currentPage - 1);
                    // Set range to end of the new page
                    state.endDateIndex = state.dates.length - 1;
                    state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                    // Continue playing
                } else {
                    // Reached the very beginning
                    stopAnimation();
                }
            }, state.animationSpeed);
        }

        function toggleHelp() {
            const helpPanel = document.getElementById('help-panel');
            const helpOverlay = document.getElementById('help-overlay');
            helpPanel.classList.toggle('visible');
            helpOverlay.classList.toggle('visible');
        }

        function snapToStart() {
            const rangeDuration = state.endDateIndex - state.startDateIndex;

            // If already at the start of current page, go to previous page
            if (state.startDateIndex === 0 && state.currentPage > 0) {
                setPage(state.currentPage - 1);
                // Snap to start of the new page
                state.startDateIndex = 0;
                state.endDateIndex = Math.min(rangeDuration, state.dates.length - 1);
            } else {
                // Snap to start of current page
                state.startDateIndex = 0;
                state.endDateIndex = Math.min(rangeDuration, state.dates.length - 1);
            }

            document.getElementById('slider-start').value = state.startDateIndex;
            document.getElementById('slider-end').value = state.endDateIndex;
            updateSliderRange();
            updateDisplay();
        }

        function snapToEnd() {
            const rangeDuration = state.endDateIndex - state.startDateIndex;

            // If already at the end of current page, go to next page
            if (state.endDateIndex === state.dates.length - 1 && state.currentPage < state.totalPages - 1) {
                setPage(state.currentPage + 1);
                // Snap to end of the new page
                state.endDateIndex = state.dates.length - 1;
                state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
            } else {
                // Snap to end of current page
                state.endDateIndex = state.dates.length - 1;
                state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
            }

            document.getElementById('slider-start').value = state.startDateIndex;
            document.getElementById('slider-end').value = state.endDateIndex;
            updateSliderRange();
            updateDisplay();
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Event handlers
        function setupEventHandlers() {
            const canvas = state.canvas;
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');

            // Range sliders
            sliderStart.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value <= state.endDateIndex) {
                    state.startDateIndex = value;
                    updateSliderRange();
                    updateDisplay();
                } else {
                    e.target.value = state.startDateIndex;
                }
            });

            sliderEnd.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= state.startDateIndex) {
                    state.endDateIndex = value;
                    updateSliderRange();
                    updateDisplay();
                } else {
                    e.target.value = state.endDateIndex;
                }
            });

            // Time inputs
            const startTimeInput = document.getElementById('start-time-input');
            const endTimeInput = document.getElementById('end-time-input');

            startTimeInput.addEventListener('input', (e) => {
                state.startTimeUTC = e.target.value;
                updateSliderRange();
                render();
                updateExternalLinks();
            });

            endTimeInput.addEventListener('input', (e) => {
                state.endTimeUTC = e.target.value;
                updateSliderRange();
                render();
                updateExternalLinks();
            });

            // Range dragging
            const sliderRange = document.getElementById('slider-range');
            const sliderContainer = document.getElementById('slider-container');

            sliderRange.addEventListener('mousedown', (e) => {
                e.preventDefault();
                state.isRangeDragging = true;

                // Calculate which index the mouse is at
                const rect = sliderContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const clickIndex = Math.round(percent * (state.dates.length - 1));
                state.rangeDragStartIndex = clickIndex;
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.isRangeDragging) return;

                const rect = sliderContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const currentIndex = Math.round(percent * (state.dates.length - 1));

                // Calculate the offset from where we started dragging
                const offset = currentIndex - state.rangeDragStartIndex;

                // Calculate new range maintaining the same duration
                const rangeDuration = state.endDateIndex - state.startDateIndex;
                let newStartIndex = state.startDateIndex + offset;
                let newEndIndex = state.endDateIndex + offset;

                // Clamp to valid range
                if (newStartIndex < 0) {
                    newStartIndex = 0;
                    newEndIndex = rangeDuration;
                } else if (newEndIndex >= state.dates.length) {
                    newEndIndex = state.dates.length - 1;
                    newStartIndex = newEndIndex - rangeDuration;
                }

                // Update state and sliders
                state.startDateIndex = newStartIndex;
                state.endDateIndex = newEndIndex;
                state.rangeDragStartIndex = currentIndex;

                sliderStart.value = state.startDateIndex;
                sliderEnd.value = state.endDateIndex;

                updateSliderRange();
                updateDisplay();
            });

            document.addEventListener('mouseup', () => {
                state.isRangeDragging = false;
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input field
                if (e.target.tagName === 'INPUT') return;

                if (e.key === 'Home') {
                    e.preventDefault();
                    snapToStart();
                } else if (e.key === 'End') {
                    e.preventDefault();
                    snapToEnd();
                } else if (e.key === ' ' || e.key === 'Spacebar') {
                    e.preventDefault();
                    if (state.animationId) {
                        stopAnimation();
                    } else {
                        playAnimation();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    prevPage();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    nextPage();
                }
            });

            // Speed control
            const speedSlider = document.getElementById('speed-slider');
            const speedDisplay = document.getElementById('speed-display');

            speedSlider.addEventListener('input', (e) => {
                state.animationSpeed = parseInt(e.target.value);
                speedDisplay.textContent = (state.animationSpeed / 1000).toFixed(1) + 's';

                // Restart animation if currently playing
                if (state.animationId) {
                    playAnimation();
                }
            });

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom(delta, x, y);
            });

            // Pan
            canvas.addEventListener('mousedown', (e) => {
                state.isDragging = true;
                state.dragStart = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!state.isDragging) return;

                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;

                state.transform.offsetX += dx;
                state.transform.offsetY += dy;

                state.dragStart = { x: e.clientX, y: e.clientY };
                render();
            });

            canvas.addEventListener('mouseup', () => {
                state.isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                state.isDragging = false;
            });

            // Resize
            window.addEventListener('resize', () => {
                resizeCanvas();
                fitImageToCanvas();
                render();
            });
        }

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('map-container');
            state.canvas.width = container.clientWidth;
            state.canvas.height = container.clientHeight;
        }

        // Initialize
        async function init() {
            state.canvas = document.getElementById('canvas');
            state.ctx = state.canvas.getContext('2d');

            resizeCanvas();

            // Initialize proj4 transformer first (needed for vessel track coordinate conversion)
            if (CONFIG.projection === null) {
                // Would need to load metadata here, but we have hardcoded values
                updateStatus('Error: No projection defined');
                return;
            } else {
                // Using manually specified metadata
                proj4.defs('CUSTOM', CONFIG.projection);
                state.transformer = proj4('EPSG:4326', 'CUSTOM');
                updateStatus('Using manual metadata');
            }

            // Load vessel track FIRST to determine date range
            const trackRange = await loadVesselTrack();

            // Debug: show current CONFIG.endDate
            console.log('CONFIG.endDate before check:', CONFIG.endDate.toISOString());

            // Extend CONFIG.endDate if vessel track has data beyond current endDate
            // Compare using end-of-day to handle timezone edge cases
            if (trackRange) {
                const trackEndOfDay = new Date(trackRange.maxDate);
                trackEndOfDay.setUTCHours(23, 59, 59, 999);

                console.log('Track maxDate:', trackRange.maxDate.toISOString());
                console.log('Track end of day:', trackEndOfDay.toISOString());
                console.log('CONFIG.endDate:', CONFIG.endDate.toISOString());

                if (trackEndOfDay > CONFIG.endDate) {
                    console.log('Extending date range to include full track day');
                    CONFIG.endDate = trackEndOfDay;
                    console.log('New CONFIG.endDate:', CONFIG.endDate.toISOString());
                }
            }

            // Generate all dates and calculate pagination (now includes vessel track range)
            state.allDates = generateAllDates();
            state.totalPages = Math.ceil(state.allDates.length / CONFIG.daysPerPage);
            state.currentPage = state.totalPages - 1;  // Start on most recent page

            // Get dates for current page
            state.dates = getPageDates();

            // Default to last 14 days of the range
            state.endDateIndex = state.dates.length - 1;
            state.startDateIndex = Math.max(0, state.endDateIndex - 13);

            // Setup sliders
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            sliderStart.max = state.dates.length - 1;
            sliderEnd.max = state.dates.length - 1;
            sliderStart.value = state.startDateIndex;
            sliderEnd.value = state.endDateIndex;

            // Initialize range visual and page display
            updateSliderRange();
            updatePageDisplay();

            // Load coastline
            await loadCoastline();

            // Set initial coastline toggle state
            if (state.showCoastline) {
                document.getElementById('coastline-toggle').classList.add('active');
            }

            // Setup event handlers
            setupEventHandlers();

            // Initial display
            fitImageToCanvas();
            await updateDisplay();

            updateStatus('Ready');
        }

        // Start
        init();
    </script>
</body>
</html>
