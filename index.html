<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vessel Track Map Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a0a;
        }
        
        #canvas {
            position: absolute;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #controls {
            background: #2a2a2a;
            padding: 20px;
            border-top: 1px solid #404040;
        }
        
        #timeline {
            margin-bottom: 15px;
        }
        
        #slider-container {
            position: relative;
            height: 40px;
            margin-bottom: 10px;
        }
        
        .time-slider {
            position: absolute;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            pointer-events: none;
        }
        
        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 3;
        }
        
        .time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            border: none;
            pointer-events: auto;
        }
        
        #slider-end::-webkit-slider-thumb {
            background: #ff6b6b;
        }
        
        #slider-end::-moz-range-thumb {
            background: #ff6b6b;
        }
        
        #slider-track {
            position: absolute;
            height: 8px;
            background: #404040;
            border-radius: 4px;
            width: 100%;
            top: 16px;
        }
        
        #slider-range {
            position: absolute;
            height: 8px;
            background: #4a9eff;
            border-radius: 4px;
            top: 16px;
            cursor: pointer;
        }
        
        #date-range {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        
        #datetime-readout {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            text-align: right;
            line-height: 1.4;
        }
        
        #datetime-readout .start-time,
        #datetime-readout .end-time {
            color: #888;
        }
        
        #info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 14px;
        }
        
        #date-display {
            font-weight: 600;
            color: #4a9eff;
            font-size: 16px;
        }
        
        .controls-group {
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #404040;
            color: #e0e0e0;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #505050;
        }
        
        button:active {
            background: #353535;
        }
        
        #loading {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.9);
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        
        .status {
            font-size: 12px;
            color: #999;
        }
        
        #help-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
        }
        
        #help-panel.visible {
            display: block;
        }
        
        #help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 999;
        }
        
        #help-overlay.visible {
            display: block;
        }
        
        #help-panel h2 {
            margin-top: 0;
            color: #4a9eff;
        }
        
        #help-panel h3 {
            color: #ff6b6b;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        #help-panel ul {
            line-height: 1.6;
            padding-left: 20px;
        }
        
        #help-panel li {
            margin-bottom: 8px;
        }
        
        #help-panel code {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .close-help {
            float: right;
            background: #404040;
            border: none;
            color: #e0e0e0;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .close-help:hover {
            background: #505050;
        }
        
        #zoom-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 20px;
            font-weight: bold;
        }
        
        #coastline-toggle.active {
            background: #4a9eff;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="help-overlay" onclick="toggleHelp()"></div>
        <div id="help-panel">
            <button class="close-help" onclick="toggleHelp()">‚úï Close</button>
            <h2>Vessel Track Map Viewer</h2>
            
            <h3>üìÖ Timeline Controls</h3>
            <ul>
                <li><strong>Previous/Next Period:</strong> Navigate between year-long periods (2020-2025)</li>
                <li><strong>Blue slider (left):</strong> Start date of the range</li>
                <li><strong>Red slider (right):</strong> End date of the range</li>
                <li><strong>Blue highlighted bar:</strong> Click and drag to slide the entire time window</li>
                <li><strong>Vessel track:</strong> Displays only within the selected date range</li>
            </ul>
            
            <h3>‚ñ∂Ô∏è Animation</h3>
            <ul>
                <li><strong>Play (‚ñ∂):</strong> Animate the time window forward</li>
                <li><strong>Reverse (‚óÄ):</strong> Animate the time window backward</li>
                <li><strong>Pause (‚è∏):</strong> Stop animation</li>
                <li><strong>‚èÆ Start:</strong> Snap to start of period (or previous period if already at start)</li>
                <li><strong>End ‚è≠:</strong> Snap to end of period (or next period if already at end)</li>
                <li><strong>Speed slider:</strong> Adjust animation speed (0.1s to 2.0s per frame)</li>
            </ul>
            
            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <ul>
                <li><strong>Home:</strong> Snap to start (or previous period)</li>
                <li><strong>End:</strong> Snap to end (or next period)</li>
                <li><strong>Space:</strong> Toggle play/pause animation</li>
                <li><strong>Arrow Left:</strong> Previous period</li>
                <li><strong>Arrow Right:</strong> Next period</li>
            </ul>
            
            <h3>üó∫Ô∏è Map Navigation</h3>
            <ul>
                <li><strong>Click and drag:</strong> Pan the map</li>
                <li><strong>Mouse wheel:</strong> Zoom in/out at cursor position</li>
                <li><strong>+ button:</strong> Zoom in at center</li>
                <li><strong>‚àí button:</strong> Zoom out at center</li>
                <li><strong>‚åÇ button:</strong> Reset to original view</li>
            </ul>
            
            <h3>üö¢ Vessel Track</h3>
            <ul>
                <li><strong>Red line:</strong> Vessel path during selected time range</li>
                <li><strong>Red dot:</strong> Vessel position at end of range</li>
                <li><strong>Tip:</strong> Set start = end for a single-day snapshot</li>
            </ul>
            
            <h3>üñºÔ∏è Background Images</h3>
            <ul>
                <li>Background image aligns to the <strong>end date</strong> of the range</li>
                <li>If an image is missing, the viewer automatically uses the nearest earlier date</li>
                <li>Status message shows if a fallback image is being used</li>
            </ul>
        </div>
        
        <div id="map-container">
            <canvas id="canvas"></canvas>
            <div id="loading">Loading...</div>
            <div id="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <button class="zoom-btn" onclick="resetView()">‚åÇ</button>
                <button class="zoom-btn" onclick="toggleCoastline()" id="coastline-toggle" title="Toggle coastline">üó∫Ô∏è</button>
            </div>
        </div>
        
        <div id="controls">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="prev-page" onclick="prevPage()">‚óÑ Previous Period</button>
                    <span id="page-info" style="font-size: 14px; color: #999;"></span>
                    <button id="next-page" onclick="nextPage()">Next Period ‚ñ∫</button>
                </div>
                <div id="datetime-readout">
                    <div class="start-time"><span id="start-datetime"></span></div>
                    <div class="end-time"><span id="end-datetime"></span></div>
                </div>
            </div>
            <div id="timeline">
                <div id="slider-container">
                    <div id="slider-track"></div>
                    <div id="slider-range"></div>
                    <input type="range" id="slider-start" class="time-slider" min="0" max="364" value="350" step="1">
                    <input type="range" id="slider-end" class="time-slider" min="0" max="364" value="364" step="1">
                </div>
                <div id="date-range">
                    <span id="start-date"></span>
                    <span id="end-date"></span>
                </div>
            </div>
            <div id="info">
                <div id="date-display">Loading...</div>
                <div class="status" id="status">Initializing...</div>
                <div class="controls-group">
                    <button onclick="snapToStart()" title="Snap to start of period (Home)">‚èÆ Start</button>
                    <button onclick="playReverse()">‚óÄ Reverse</button>
                    <button onclick="playAnimation()">‚ñ∂ Play</button>
                    <button onclick="stopAnimation()">‚è∏ Pause</button>
                    <button onclick="snapToEnd()" title="Snap to end of period (End)">End ‚è≠</button>
                    <label style="margin-left: 15px; display: flex; align-items: center; gap: 8px;">
                        Speed:
                        <input type="range" id="speed-slider" min="100" max="2000" value="500" step="100" 
                               style="width: 100px; height: 6px;">
                        <span id="speed-display">0.5s</span>
                    </label>
                </div>
                <button onclick="toggleHelp()" style="margin-left: auto;">‚ùì Help</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            imageBaseUrl: 'https://projects.pawsey.org.au/nuyina.map/NOAA/G02135',
            trackUrl: 'https://raw.githubusercontent.com/mdsumner/seaice.map/refs/heads/main/vessel_track_hourly.json',
            projection: '+proj=tmerc +lat_0=0 +lon_0=115 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs',
            extent: {
                xmin: -6007500,
                xmax: 6012500,
                ymin: -14422000,
                ymax: 14418000
            },
            imageWidth: 601,
            imageHeight: 1442,
            daysPerPage: 365,  // Show 1 year per page
            endDate: (() => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                return today;
            })(),  // Use today - vessel data up to date, background image falls back to latest available
            startDate: new Date('2020-06-01T00:00:00Z')  // Start from June 1st for seasonal alignment
        };

        // State
        let state = {
            canvas: null,
            ctx: null,
            dates: [],
            allDates: [],  // All available dates across all pages
            currentPage: 0,
            totalPages: 0,
            startDateIndex: 0,
            endDateIndex: 0,
            vesselTrack: [],
            transform: {
                scale: 1,
                offsetX: 0,
                offsetY: 0
            },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            animationId: null,
            imageCache: {},
            currentImage: null,
            isRangeDragging: false,
            rangeDragStartIndex: 0,
            animationSpeed: 500,  // milliseconds per frame
            coastline: null,
            showCoastline: true
        };

        // Initialize proj4
        proj4.defs('CUSTOM', CONFIG.projection);
        const transformer = proj4('EPSG:4326', 'CUSTOM');

        // Generate all available dates
        function generateAllDates() {
            const dates = [];
            const start = new Date(CONFIG.startDate);
            const end = new Date(CONFIG.endDate);
            
            let current = new Date(start);
            while (current <= end) {
                dates.push(new Date(current));
                current.setDate(current.getDate() + 1);
            }
            
            return dates;
        }
        
        // Get dates for current page
        function getPageDates() {
            const startIdx = state.currentPage * CONFIG.daysPerPage;
            const endIdx = Math.min(startIdx + CONFIG.daysPerPage, state.allDates.length);
            return state.allDates.slice(startIdx, endIdx);
        }
        
        // Update page
        function setPage(pageNum) {
            state.currentPage = Math.max(0, Math.min(pageNum, state.totalPages - 1));
            state.dates = getPageDates();
            
            // Reset range to last 14 days of current page
            state.endDateIndex = state.dates.length - 1;
            state.startDateIndex = Math.max(0, state.endDateIndex - 13);
            
            // Update sliders
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            sliderStart.max = state.dates.length - 1;
            sliderEnd.max = state.dates.length - 1;
            sliderStart.value = state.startDateIndex;
            sliderEnd.value = state.endDateIndex;
            
            updateSliderRange();
            updatePageDisplay();
            updateDisplay();
        }
        
        function nextPage() {
            if (state.currentPage < state.totalPages - 1) {
                setPage(state.currentPage + 1);
            }
        }
        
        function prevPage() {
            if (state.currentPage > 0) {
                setPage(state.currentPage - 1);
            }
        }
        
        function updatePageDisplay() {
            const pageInfo = document.getElementById('page-info');
            const startDate = formatDate(state.dates[0]);
            const endDate = formatDate(state.dates[state.dates.length - 1]);
            pageInfo.textContent = `Period: ${startDate} to ${endDate} (Page ${state.currentPage + 1}/${state.totalPages})`;
            
            // Enable/disable buttons
            document.getElementById('prev-page').disabled = state.currentPage === 0;
            document.getElementById('next-page').disabled = state.currentPage === state.totalPages - 1;
        }

        // Format date as YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        // Format datetime as YYYY-MM-DD HH:MM:SS UTC
        function formatDateTime(date) {
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
        }

        // Get image URL for a date
        function getImageUrl(date) {
            const dateStr = formatDate(date);
            const year = date.getFullYear();
            const url = `${CONFIG.imageBaseUrl}/${year}/concentration_v4.0_${dateStr}.png`;
            
            // Uncomment to use CORS proxy (for testing only):
            return `https://corsproxy.io/?${encodeURIComponent(url)}`;
            
            return url;
        }

        // Load image with fallback
        async function loadImageWithFallback(dateIndex) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            for (let i = dateIndex; i >= 0; i--) {
                const date = state.dates[i];
                const url = getImageUrl(date);
                
                // Check cache first
                if (state.imageCache[url]) {
                    loading.style.display = 'none';
                    return { image: state.imageCache[url], date };
                }
                
                try {
                    const img = await loadImage(url);
                    state.imageCache[url] = img;
                    loading.style.display = 'none';
                    updateStatus(i === dateIndex ? 
                        'Image loaded' : 
                        `Using fallback from ${formatDate(date)}`);
                    return { image: img, date };
                } catch (e) {
                    // Try previous date
                    continue;
                }
            }
            
            loading.style.display = 'none';
            updateStatus('No images available');
            return null;
        }

        // Load image promise
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        // Convert lon/lat to pixel coordinates
        function lonLatToPixel(lon, lat) {
            // Transform to projected coordinates
            const [x, y] = transformer.forward([lon, lat]);
            
            // Convert projected coordinates to pixel coordinates
            const pixelX = ((x - CONFIG.extent.xmin) / (CONFIG.extent.xmax - CONFIG.extent.xmin)) * CONFIG.imageWidth;
            const pixelY = ((CONFIG.extent.ymax - y) / (CONFIG.extent.ymax - CONFIG.extent.ymin)) * CONFIG.imageHeight;
            
            return { x: pixelX, y: pixelY };
        }

        // Load coastline data
        async function loadCoastline() {
            try {
                // Using simplified GeoJSON coastline
                const response = await fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_coastline.geojson');
                const data = await response.json();
                
                console.log('Coastline data loaded:', data.features.length, 'features');
                
                // Calculate maximum reasonable segment length (e.g., 20% of image height)
                const maxSegmentLength = CONFIG.imageHeight * 0.2;
                
                // Convert GeoJSON to pixel coordinates and filter out wrap-around segments
                const coastlinePixels = [];
                
                data.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString') {
                        const coords = feature.geometry.coordinates.map(coord => {
                            const [lon, lat] = coord;
                            return lonLatToPixel(lon, lat);
                        });
                        
                        // Split into segments, filtering out long ones
                        const segments = splitAndFilterSegments(coords, maxSegmentLength);
                        coastlinePixels.push(...segments);
                        
                    } else if (feature.geometry.type === 'MultiLineString') {
                        feature.geometry.coordinates.forEach(lineString => {
                            const coords = lineString.map(coord => {
                                const [lon, lat] = coord;
                                return lonLatToPixel(lon, lat);
                            });
                            
                            // Split into segments, filtering out long ones
                            const segments = splitAndFilterSegments(coords, maxSegmentLength);
                            coastlinePixels.push(...segments);
                        });
                    }
                });
                
                console.log('Coastline pixels:', coastlinePixels.length, 'line segments');
                state.coastline = coastlinePixels;
                updateStatus('Coastline loaded');
                render();
            } catch (e) {
                console.error('Failed to load coastline:', e);
                updateStatus('Coastline unavailable');
                state.coastline = null;
            }
        }
        
        // Split a line into segments, removing those that are too long (wrap-around artifacts)
        function splitAndFilterSegments(coords, maxLength) {
            const segments = [];
            let currentSegment = [];
            
            for (let i = 0; i < coords.length; i++) {
                const point = coords[i];
                
                if (currentSegment.length > 0) {
                    const prevPoint = currentSegment[currentSegment.length - 1];
                    const dx = point.x - prevPoint.x;
                    const dy = point.y - prevPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > maxLength) {
                        // This segment is too long (likely a wrap-around)
                        // Save current segment if it has multiple points
                        if (currentSegment.length > 1) {
                            segments.push(currentSegment);
                        }
                        // Start a new segment
                        currentSegment = [point];
                    } else {
                        currentSegment.push(point);
                    }
                } else {
                    currentSegment.push(point);
                }
            }
            
            // Add the last segment
            if (currentSegment.length > 1) {
                segments.push(currentSegment);
            }
            
            return segments;
        }
        
        // Toggle coastline visibility
        function toggleCoastline() {
            state.showCoastline = !state.showCoastline;
            const btn = document.getElementById('coastline-toggle');
            if (state.showCoastline) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            render();
        }

        // Load vessel track
        async function loadVesselTrack() {
            try {
                const response = await fetch(CONFIG.trackUrl);
                const data = await response.json();
                
                // Convert to pixel coordinates
                state.vesselTrack = data.map(point => {
                    const pixels = lonLatToPixel(point.longitude, point.latitude);
                    return {
                        datetime: new Date(point.datetime),
                        x: pixels.x,
                        y: pixels.y,
                        lon: point.longitude,
                        lat: point.latitude
                    };
                });
                
                updateStatus(`Loaded ${state.vesselTrack.length} track points`);
            } catch (e) {
                console.error('Failed to load vessel track:', e);
                updateStatus('Failed to load vessel track');
            }
        }

        // Render canvas
        function render() {
            const canvas = state.canvas;
            const ctx = state.ctx;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!state.currentImage) return;
            
            // Calculate transform
            const scale = state.transform.scale;
            const offsetX = state.transform.offsetX;
            const offsetY = state.transform.offsetY;
            
            // Draw image
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.drawImage(state.currentImage, 0, 0, CONFIG.imageWidth, CONFIG.imageHeight);
            ctx.restore();
            
            // Draw coastline
            if (state.showCoastline && state.coastline) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1 / scale;  // Adjust line width based on zoom
                
                state.coastline.forEach(ring => {
                    if (ring.length < 2) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(ring[0].x, ring[0].y);
                    for (let i = 1; i < ring.length; i++) {
                        ctx.lineTo(ring[i].x, ring[i].y);
                    }
                    ctx.stroke();
                });
                
                ctx.restore();
            }
            
            // Draw vessel track for the selected date range
            if (state.vesselTrack.length > 0) {
                const startDate = state.dates[state.startDateIndex];
                const endDate = state.dates[state.endDateIndex];
                const relevantPoints = state.vesselTrack.filter(p => 
                    p.datetime >= startDate && p.datetime <= endDate
                );
                
                if (relevantPoints.length > 0) {
                    // Draw track line
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    relevantPoints.forEach((point, i) => {
                        const x = point.x * scale + offsetX;
                        const y = point.y * scale + offsetY;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                    
                    // Draw end position (last point in range)
                    const lastPoint = relevantPoints[relevantPoints.length - 1];
                    const x = lastPoint.x * scale + offsetX;
                    const y = lastPoint.y * scale + offsetY;
                    
                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Update display
        async function updateDisplay() {
            const result = await loadImageWithFallback(state.endDateIndex);
            if (result) {
                state.currentImage = result.image;
                document.getElementById('date-display').textContent = 
                    `${formatDate(state.dates[state.startDateIndex])} ‚Üí ${formatDate(result.date)}`;
                render();
            }
        }

        // Update slider range visual
        function updateSliderRange() {
            const sliderRange = document.getElementById('slider-range');
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            
            const percent1 = (state.startDateIndex / (state.dates.length - 1)) * 100;
            const percent2 = (state.endDateIndex / (state.dates.length - 1)) * 100;
            
            sliderRange.style.left = percent1 + '%';
            sliderRange.style.width = (percent2 - percent1) + '%';
            
            // Update date range display
            document.getElementById('start-date').textContent = formatDate(state.dates[state.startDateIndex]);
            document.getElementById('end-date').textContent = formatDate(state.dates[state.endDateIndex]);
            
            // Update datetime readout
            document.getElementById('start-datetime').textContent = formatDateTime(state.dates[state.startDateIndex]);
            document.getElementById('end-datetime').textContent = formatDateTime(state.dates[state.endDateIndex]);
        }

        // Fit image to canvas
        function fitImageToCanvas() {
            const canvas = state.canvas;
            const scaleX = canvas.width / CONFIG.imageWidth;
            const scaleY = canvas.height / CONFIG.imageHeight;
            const scale = Math.min(scaleX, scaleY);
            
            state.transform.scale = scale;
            state.transform.offsetX = (canvas.width - CONFIG.imageWidth * scale) / 2;
            state.transform.offsetY = (canvas.height - CONFIG.imageHeight * scale) / 2;
        }

        // Zoom functions
        function zoomIn() {
            const canvas = state.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            zoom(1.2, centerX, centerY);
        }

        function zoomOut() {
            const canvas = state.canvas;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            zoom(0.8, centerX, centerY);
        }

        function zoom(factor, centerX, centerY) {
            const oldScale = state.transform.scale;
            const newScale = oldScale * factor;
            
            // Calculate new offset to zoom towards center point
            state.transform.offsetX = centerX - (centerX - state.transform.offsetX) * (newScale / oldScale);
            state.transform.offsetY = centerY - (centerY - state.transform.offsetY) * (newScale / oldScale);
            state.transform.scale = newScale;
            
            render();
        }

        function resetView() {
            fitImageToCanvas();
            render();
        }

        // Animation
        function playAnimation() {
            if (state.animationId) {
                stopAnimation();
            }
            
            state.animationId = setInterval(() => {
                const rangeDuration = state.endDateIndex - state.startDateIndex;
                
                if (state.endDateIndex < state.dates.length - 1) {
                    // Move both start and end forward by 1, maintaining range duration
                    state.startDateIndex++;
                    state.endDateIndex++;
                    
                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                } else if (state.currentPage < state.totalPages - 1) {
                    // Reached end of current page, advance to next page
                    setPage(state.currentPage + 1);
                    // Continue playing
                } else {
                    // Reached the very end
                    stopAnimation();
                }
            }, state.animationSpeed);
        }

        function stopAnimation() {
            if (state.animationId) {
                clearInterval(state.animationId);
                state.animationId = null;
            }
        }
        
        function playReverse() {
            if (state.animationId) {
                stopAnimation();
            }
            
            state.animationId = setInterval(() => {
                const rangeDuration = state.endDateIndex - state.startDateIndex;
                
                if (state.startDateIndex > 0) {
                    // Move both start and end backward by 1, maintaining range duration
                    state.startDateIndex--;
                    state.endDateIndex--;
                    
                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                } else if (state.currentPage > 0) {
                    // Reached start of current page, go back to previous page
                    setPage(state.currentPage - 1);
                    // Set range to end of the new page
                    state.endDateIndex = state.dates.length - 1;
                    state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
                    document.getElementById('slider-start').value = state.startDateIndex;
                    document.getElementById('slider-end').value = state.endDateIndex;
                    updateSliderRange();
                    updateDisplay();
                    // Continue playing
                } else {
                    // Reached the very beginning
                    stopAnimation();
                }
            }, state.animationSpeed);
        }
        
        function toggleHelp() {
            const helpPanel = document.getElementById('help-panel');
            const helpOverlay = document.getElementById('help-overlay');
            helpPanel.classList.toggle('visible');
            helpOverlay.classList.toggle('visible');
        }
        
        function snapToStart() {
            const rangeDuration = state.endDateIndex - state.startDateIndex;
            
            // If already at the start of current page, go to previous page
            if (state.startDateIndex === 0 && state.currentPage > 0) {
                setPage(state.currentPage - 1);
                // Snap to start of the new page
                state.startDateIndex = 0;
                state.endDateIndex = Math.min(rangeDuration, state.dates.length - 1);
            } else {
                // Snap to start of current page
                state.startDateIndex = 0;
                state.endDateIndex = Math.min(rangeDuration, state.dates.length - 1);
            }
            
            document.getElementById('slider-start').value = state.startDateIndex;
            document.getElementById('slider-end').value = state.endDateIndex;
            updateSliderRange();
            updateDisplay();
        }
        
        function snapToEnd() {
            const rangeDuration = state.endDateIndex - state.startDateIndex;
            
            // If already at the end of current page, go to next page
            if (state.endDateIndex === state.dates.length - 1 && state.currentPage < state.totalPages - 1) {
                setPage(state.currentPage + 1);
                // Snap to end of the new page
                state.endDateIndex = state.dates.length - 1;
                state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
            } else {
                // Snap to end of current page
                state.endDateIndex = state.dates.length - 1;
                state.startDateIndex = Math.max(0, state.endDateIndex - rangeDuration);
            }
            
            document.getElementById('slider-start').value = state.startDateIndex;
            document.getElementById('slider-end').value = state.endDateIndex;
            updateSliderRange();
            updateDisplay();
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Event handlers
        function setupEventHandlers() {
            const canvas = state.canvas;
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            
            // Range sliders
            sliderStart.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value <= state.endDateIndex) {
                    state.startDateIndex = value;
                    updateSliderRange();
                    updateDisplay();
                } else {
                    e.target.value = state.startDateIndex;
                }
            });
            
            sliderEnd.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= state.startDateIndex) {
                    state.endDateIndex = value;
                    updateSliderRange();
                    updateDisplay();
                } else {
                    e.target.value = state.endDateIndex;
                }
            });
            
            // Range dragging
            const sliderRange = document.getElementById('slider-range');
            const sliderContainer = document.getElementById('slider-container');
            
            sliderRange.addEventListener('mousedown', (e) => {
                e.preventDefault();
                state.isRangeDragging = true;
                
                // Calculate which index the mouse is at
                const rect = sliderContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const clickIndex = Math.round(percent * (state.dates.length - 1));
                state.rangeDragStartIndex = clickIndex;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!state.isRangeDragging) return;
                
                const rect = sliderContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const currentIndex = Math.round(percent * (state.dates.length - 1));
                
                // Calculate the offset from where we started dragging
                const offset = currentIndex - state.rangeDragStartIndex;
                
                // Calculate new range maintaining the same duration
                const rangeDuration = state.endDateIndex - state.startDateIndex;
                let newStartIndex = state.startDateIndex + offset;
                let newEndIndex = state.endDateIndex + offset;
                
                // Clamp to valid range
                if (newStartIndex < 0) {
                    newStartIndex = 0;
                    newEndIndex = rangeDuration;
                } else if (newEndIndex >= state.dates.length) {
                    newEndIndex = state.dates.length - 1;
                    newStartIndex = newEndIndex - rangeDuration;
                }
                
                // Update state and sliders
                state.startDateIndex = newStartIndex;
                state.endDateIndex = newEndIndex;
                state.rangeDragStartIndex = currentIndex;
                
                sliderStart.value = state.startDateIndex;
                sliderEnd.value = state.endDateIndex;
                
                updateSliderRange();
                updateDisplay();
            });
            
            document.addEventListener('mouseup', () => {
                state.isRangeDragging = false;
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input field
                if (e.target.tagName === 'INPUT') return;
                
                if (e.key === 'Home') {
                    e.preventDefault();
                    snapToStart();
                } else if (e.key === 'End') {
                    e.preventDefault();
                    snapToEnd();
                } else if (e.key === ' ' || e.key === 'Spacebar') {
                    e.preventDefault();
                    if (state.animationId) {
                        stopAnimation();
                    } else {
                        playAnimation();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    prevPage();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    nextPage();
                }
            });
            
            // Speed control
            const speedSlider = document.getElementById('speed-slider');
            const speedDisplay = document.getElementById('speed-display');
            
            speedSlider.addEventListener('input', (e) => {
                state.animationSpeed = parseInt(e.target.value);
                speedDisplay.textContent = (state.animationSpeed / 1000).toFixed(1) + 's';
                
                // Restart animation if currently playing
                if (state.animationId) {
                    playAnimation();
                }
            });
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom(delta, x, y);
            });
            
            // Pan
            canvas.addEventListener('mousedown', (e) => {
                state.isDragging = true;
                state.dragStart = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!state.isDragging) return;
                
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                
                state.transform.offsetX += dx;
                state.transform.offsetY += dy;
                
                state.dragStart = { x: e.clientX, y: e.clientY };
                render();
            });
            
            canvas.addEventListener('mouseup', () => {
                state.isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                state.isDragging = false;
            });
            
            // Resize
            window.addEventListener('resize', () => {
                resizeCanvas();
                fitImageToCanvas();
                render();
            });
        }

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('map-container');
            state.canvas.width = container.clientWidth;
            state.canvas.height = container.clientHeight;
        }

        // Initialize
        async function init() {
            state.canvas = document.getElementById('canvas');
            state.ctx = state.canvas.getContext('2d');
            
            resizeCanvas();
            
            // Generate all dates and calculate pagination
            state.allDates = generateAllDates();
            state.totalPages = Math.ceil(state.allDates.length / CONFIG.daysPerPage);
            state.currentPage = state.totalPages - 1;  // Start on most recent page
            
            // Get dates for current page
            state.dates = getPageDates();
            
            // Default to last 14 days of the range
            state.endDateIndex = state.dates.length - 1;
            state.startDateIndex = Math.max(0, state.endDateIndex - 13);
            
            // Setup sliders
            const sliderStart = document.getElementById('slider-start');
            const sliderEnd = document.getElementById('slider-end');
            sliderStart.max = state.dates.length - 1;
            sliderEnd.max = state.dates.length - 1;
            sliderStart.value = state.startDateIndex;
            sliderEnd.value = state.endDateIndex;
            
            // Initialize range visual and page display
            updateSliderRange();
            updatePageDisplay();
            
            // Load vessel track
            await loadVesselTrack();
            
            // Load coastline
            await loadCoastline();
            
            // Set initial coastline toggle state
            if (state.showCoastline) {
                document.getElementById('coastline-toggle').classList.add('active');
            }
            
            // Setup event handlers
            setupEventHandlers();
            
            // Initial display
            fitImageToCanvas();
            await updateDisplay();
            
            updateStatus('Ready');
        }

        // Start
        init();
    </script>
</body>
</html>
